<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Dash and Blast prototype</title>
    <link rel="stylesheet" href="/css/examples.css" />
    <script src="/js/examples.js"></script>
    <script src="/lib/phaser.min.js"></script>
    <script src="/lib/enable3d.0.0.12.main.min.js"></script>
  </head>

  <body>
    <script>
      const { enable3d, Scene3D, Canvas } = ENABLE3D

      class Player {
        object
        constructor(scene) {
          this.object = scene.third.physics.add.cylinder({ z: 10, radiusSegments: 32, collisionFlag: 16 }, { lambert: { color: 0xffffff } })
          this.object.body.setAngularFactor(0, 0, 0)
        }
      }

      class Goal {
        object
        start
        length
        radius
        speed
        centerX
        centerZ
        index
        active

        activate() {
          this.active = true
          this.object.body.setCollisionFlags(0)
          this.object.body.setAngularVelocityY(this.speed)
        }

        deactivate() {
          this.active = false
          this.object.body.setCollisionFlags(1)
          this.object.body.setAngularVelocityY(0)
        }

        constructor(scene, centerX, centerZ, index) {
          this.centerX = centerX
          this.centerZ = centerZ
          this.index = index

          this.start = Math.random() * Math.PI * 2
          this.length = (Math.random() * Math.PI) / 2 + Math.PI / 2
          this.radius = Math.random() * 3 + 4
          this.speed = Math.random() * 2 + 2

          const cylSmall = scene.third.make.cylinder({
            x: centerX,
            z: centerZ,
            y: 0.1,
            radiusTop: this.radius - 1,
            radiusBottom: this.radius - 1,
            radiusSegments: 8,
            thetaStart: this.start,
            thetaLength: this.length
          })
          const cylBig = scene.third.make.cylinder({
            x: centerX,
            z: centerZ,
            y: 0.1,
            radiusTop: this.radius,
            radiusBottom: this.radius,
            radiusSegments: 12,
            thetaStart: this.start,
            thetaLength: this.length
          })
          this.object = scene.third.mesh.subtract(cylBig, cylSmall)
          this.object.material = scene.third.new.defaultMaterial({ side: 2 })
          this.object.castShadow = this.object.receiveShadow = false
          this.object.shape = 'concave'
          scene.third.physics.add.existing(this.object, { autoCenter: false })

          this.object.body.setAngularFactor(0, 1, 0)
          this.object.body.ammo.setLinearFactor(new Ammo.btVector3(0, 0, 0))
          this.object.body.ammo.setFriction(0)
          this.object.body.setCollisionFlags(1)

          if (this.index === 0 || this.index === 1) this.activate()

          // the cylinder in the middle
          scene.third.add.cylinder({
            height: 0.2,
            x: centerX,
            y: -0.2,
            z: centerZ,
            collisionFlag: 4,
            radiusSegments: 32
          })
        }
      }

      class DashAndBlast extends Scene3D {
        goals
        player
        goalIndex
        ready
        constructor() {
          super({ key: 'DashAndBlast' })
        }

        init() {
          this.requestThirdDimension()
          this.goals = []
          delete this.player
          this.goalIndex = 0
          this.ready = false
        }

        create() {
          this.accessThirdDimension()
          this.third.warpSpeed('camera', 'sky', 'light', 'lookAtCenter', 'orbitControls')

          this.third.physics.add.ground({ width: 35, height: 220, y: -1, z: -95 }, { phong: { color: 0x95a7ef } })

          for (let i = 0; i < 10; i++) {
            this.goals.push(new Goal(this, Phaser.Math.RND.integerInRange(-6, 6), i * -20, i))
          }

          this.player = new Player(this)

          this.input.on('pointerdown', pointer => {
            const { x: vx, y: vy, z: vz } = this.player.object.body.velocity
            if (Math.abs(vx) > 1 || Math.abs(vy) > 1 || Math.abs(vz) > 1) return

            this.player.object.body.ammo.setMassProps(1, new Ammo.btVector3(1, 1, 1))
            const speed = 50
            // apply force in direction of the next goal
            const pos = this.player.object.position
            const goal = this.goals[this.goalIndex]
            const angle = Math.atan2(goal.centerX - pos.x, goal.centerZ - pos.z)

            const x = Math.sin(angle) * speed,
              y = this.player.object.body.velocity.y,
              z = Math.cos(angle) * speed

            this.player.object.body.applyForce(x, y, z)
          })
          this.ready = true
        }

        update(time, delta) {
          if (!this.ready) return
          // camera follow
          const pos = this.player.object.position.clone()
          this.third.camera.position.set(pos.x, pos.y + 20, pos.z + 20)
          this.third.camera.lookAt(pos.x, pos.y, pos.z - 5)

          // update player
          if (this.player.object.position.y < -10) this.scene.restart()
          if (this.player.object.position.z <= this.goals[this.goalIndex].centerZ) {
            this.player.object.body.setVelocity(0, 0, 0)
            this.player.object.body.ammo.setMassProps(100, new Ammo.btVector3(1, 1, 1))

            // set the player at the center of the goal
            // (this looks a bit hackie, I will try to integrated
            // it better into enable3d in future releases)
            this.player.object.body.setCollisionFlags(2)
            const t = this.third.physics.tmpTrans
            const b = this.player.object.body.ammo
            b.getMotionState().getWorldTransform(t)
            t.getOrigin().setX(this.goals[this.goalIndex].centerX)
            t.getOrigin().setZ(this.goals[this.goalIndex].centerZ)
            b.getMotionState().setWorldTransform(t)
            // this.third.physics.physicsWorld.updateSingleAabb(b)
            this.time.addEvent({
              delay: 50,
              callback: () => this.player.object.body.setCollisionFlags(0)
            })

            if (this.goalIndex < this.goals.length - 1) {
              this.goalIndex++
              this.goals.forEach((goal, i) => {
                if (this.goalIndex === i || this.goalIndex === i + 1 || this.goalIndex === i - 1) goal.activate()
                else goal.deactivate()
              })
            }
          }
        }
      }

      const config = {
        type: Phaser.WEBGL,
        scale: {
          mode: Phaser.Scale.FIT,
          autoCenter: Phaser.Scale.CENTER_BOTH,
          width: window.innerWidth * Math.max(1, window.devicePixelRatio / 2),
          height: window.innerHeight * Math.max(1, window.devicePixelRatio / 2)
        },
        scene: [DashAndBlast],
        ...Canvas()
      }

      window.addEventListener('load', () => {
        enable3d(() => new Phaser.Game(config)).withPhysics('/lib')
      })
    </script>
  </body>
</html>
